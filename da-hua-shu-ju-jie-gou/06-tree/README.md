# 树

树（Tree）是 n 个结点的有限集。n=0（n>=0）时称为空树。在任意一颗非空树中：  

1. 有且仅有一个特定的称为根(Root)的结点
2. 当 n>1 时，其余结点可分为 m (m>0) 个互不相交的有限集，T<sub>1</sub>T<sub>2</sub> …… T<sub>m</sub>; 其中每一个集合本身又是一棵树， 并且称为根的子树（ SubTree ）

## 树的定义
> 树（Tree）是 n 个结点的有限集。n=0（n>=0）时称为空树。在任意一颗非空树中：    
> 
1. 有且仅有一个特定的称为根(Root)的结点  
2. 当 n>1 时，其余结点可分为 m (m>0) 个互不相交的有限集，T<sub>1</sub>T<sub>2</sub> …… T<sub>m</sub>; 其中每一个集合本身又是一棵树， 并且称为根的子树（ SubTree ）

### 结点分类
>**结点拥有的子树数称为结点的度（Degree）**  
**度为 0 的结点称为叶节点（Leaf）或终端节点**  
**度不为 0 的结点称为非终端节点或分支结点。**  
**除根节点之外，分支节点也成为内部结点。**  
**树的度是树内各结点的度的最大值**

### 结点间关系
> **结点的子树称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）**  
**同一个双亲的孩子之间互称兄弟（Sibling）**  
**几点的祖先是从根到该结点所经分支上的所有节点。**  
**以某结点为根的子树中的任意一结点都称为该结点的子孙**

### 树的其他相关概念
>**结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层**  
**树中结点最大的层次称为树的深度（Depth）或高度**  
**如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树**  
**森林（Forest）是 m（m>=0）棵互不相交的树的集合**

## 树的抽象数据类型
```c
ADT 树（Tree）
Data
	树是由一个根节点和若干棵子树构成。树中结点具有相同数据类型及层次关系。
Operation
	InitTree(*T); 构造空树 T。
	DestoryTree(*T); 销毁树 T。
	CreateTree(*T, definition); 按 definition 中给出树的定义来构造树。
	ClearTree(*T); 若树 T 存在，则将树 T 清空。
	TreeEmpty(T); 若 T 为空树，返回 true 否则返回 false。
	TreeDepth(T); 返回 T 的深度。
	Root(T); 返回 T 的根结点。
	Value(T, cur_e); cur_e 是树 T 中一个结点，返回此结点的值。
	Assign(T, cur_e, value); 给树 T 的结点 cur_e 赋值为 value。
	Parent(T, cur_e); 若 cur_e 是树 T 的非根结点，则返回它的双亲，否则返回空。
	LeftChild(T, cur_e); 若 cur_e 是树 T 的非叶节点，则返回它的最左孩子，否则返回空。
	RightSibling(T, cur_e); 若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空。
	InsertChild(*T,*p, i, c); 其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上1，非空树 c 与 T 不相交，操作结果为插入 c 为树 T 中 p 所指结点的第 i 棵子树。
	DeleteChild(*T, *p, i); 其中 p 指向树 T 的某个结点，i 为所指结点的 p 的度，操作结果为删除 T 中 p 所指结点的第 i 棵子树。
endADT	
```
## 树的存储结构
### 双亲表示法
**在每个结点中，附设一个指示器指向其双亲结点到链表中的位置**    

```c
/* 树的双亲表示法结点结构定义 */
#define MAX_TREE_SIZE 100
typedef int TElemType;              // 树结点的数据类型, 目前暂定为整型

typedef struct PTNode {             // 结点结构
    TElemType data;                 // 结点数据
    int parent;                     // 双亲位置
} PTNode;

typedef struct {                    // 树结构
    PTNode nodes[MAX_TREE_SIZE];    // 结点数组
    int r, n;                       // 根的位置和结点数据
} PTree;
```

### 孩子表示法
**把每个结点的孩子结点排列起来，以单链表做存储结构，则 n 个节点有 n 个孩子链表，如果是叶子结点则此单链表为空，然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中**

```c
/* 树的双亲表示法结点结构定义 */
#define MAX_TREE_SIZE 100
typedef int TElemType;              // 树结点的数据类型, 目前暂定为整型

/* 树的孩子表示法结构定义 */
typedef struct CTNode {             // 孩子结点
    int child;
    struct CTNode *next;
} *ChildPtr;

typedef struct {                    // 表头结构
    TElemType data;
    ChildPtr firstChild;
} CTBox;

typedef struct {
    CTBox nodes[MAX_TREE_SIZE];     // 结点数组
    int r, n;                       // 根的位置和结点树
} CTree;

```
### 孩子兄弟表示法
**任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟**

```c
/* 树的双亲表示法结点结构定义 */
#define MAX_TREE_SIZE 100
typedef int TElemType;              // 树结点的数据类型, 目前暂定为整型

/* 树的孩子兄弟表示法结构定义 */
typedef struct CSNode {
    TElemType data;
    struct CSNode, *firstChild, *rightsib;
} CSNode, *CSTree;

```

## 二叉树的定义
>**二叉树（Binary Tree）是 n （n>=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的分别称为根结点的左子树和右子树的二叉树组成**

### 二叉树的特点

**二叉树的特点有**  

* 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点 ，注意不是只有两棵子树，而是最多有。没有子树或只有一棵子树都是可以的。
* 左子树和右子树是有顺序的，次序不能任意颠倒。
* 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

**二叉树具有五种基本形态**  

1. 空二叉树。  
2. 只有一个根结点。  
3. 根结点只有左子树。  
4. 根结点只有右子树。  
5. 根结点既有左子树又有右子树。  


### 特殊二叉树

1. 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有的结点都只有右子树的二叉树叫右斜树。这两者统称为斜树。  
2. 满二叉树：在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子结点都在同一层上，这样的二叉树称为满二叉树。  
3. 完全二叉树：对一棵具有 n 个结点的二叉树按层序标号，如果编号为 i(1<i<=n) 的结点与同样深度的满二叉树中编号为 i 的结点在满二叉树中位置完全相同，则这棵二叉树称为完全二叉树。    
**完全二叉树的特点：**  

	1. 	叶子结点只能出现在最下两层。  
	2. 最下层的叶子结点一定集中在左侧连续位置。  
	3. 倒数第二层，若有叶子结点，一定都在右部连续位置。
	4. 如果结点度为 1， 则该结点只有左孩子，即不存在只有右子树的情况。
	5. 同样结点树的二叉树，完全二叉树深度最小


## 二叉树的性质
### 二叉树性质1
**性质1：在二叉树的第 i 层上至多有2<sup>i-1</sup>个结点（i >= 1）**  

第一层是根结点， 只有一个 2<sup>1-1</sup>=2<sup>0</sup>=1  
第二层有两个，2<sup>2-1</sup>=2<sup>1</sup>=2  
第三层有四个，2<sup>3-1</sup>=2<sup>2</sup>=4  
第四层有八个，2<sup>4-1</sup>=2<sup>3</sup>=8  

### 二叉树的性质2
**性质2：深度为 k 的二叉树，至多有2<sup>k</sup>-1个结点（k>=1）**  

如果有一层，至多 1 = 2<sup>0</sup>-1  
如果有二层，至多 1 + 2 = 3 = 2<sup>2</sup>-1  
如果有三层，至多 1 + 2 + 4 = 7 = 2<sup>3</sup>-1   
如果有四层，至多 1 + 2 + 4 + 8 = 15 = 2<sup>4</sup>-1  

### 二叉树的性质3
**性质3：对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>, 度为 2 的结点数为 n<sub>2</sub>, 则 n<sub>0</sub>=n<sub>2</sub>+1**

### 二叉树的性质4
**性质4：具有 n 个结点的完全二叉树的深度为⎣㏒<sub>2</sub>n⎦+1(⎣x⎦ 表示不大于 x 的最大整数)**

### 二叉树的性质5
**性质5：如果对一棵有 n 个结点的完全二叉树（其深度为 ⎣㏒<sub>2</sub>n⎦+1）的结点按层序编号（从 1 层到⎣㏒<sub>2</sub>n⎦+1层，每层从左到右）对任一节点 i （i<= i <= n）有：**    

* **如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i>1，则其双亲是结点⎣i/2⎦**
* **如果 2i>n，则结点 i 无左孩子（结点 i 为叶子节点）；否则其左孩子是结点 2i**
* **如果2i+1>n, 则结点 i 无右孩子；否则其右孩子是结点2i+1**


## 二叉树的存储结构
### 二叉链表
**二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样的链表称为二叉链表**

```
/* 二叉树的二叉链表结点结构定义*/
typedef struct BiTNode {
    TElemType data;                     // 结点数据
    struct BiTNode *lchild, *rchild;    // 左右孩子指针
} BiTNode, *BiTree;
```



















